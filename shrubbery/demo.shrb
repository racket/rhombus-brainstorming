let (x = 1,
     y = 2):
  x+y

let (x = 1, y = 2): x+y

define pi: 3.14

define fib(n):
  log_error("fib called")
  cond | n == 0: 0
       | n == 1: 1
       | else: fib(n-1) + fib(n-2)

define
 | fib(0): 0
 | fib(1): 1
 | fib(n): fib(n-1) + fib(n-2)

define
 | fib(0): 0
 | fib(1): 1
 | fib(n): (fib(n-1) // in parens => `+` continues this line
            + fib(n-2))

define fib:
  lambda (n):
    cond
     | n == 0: 0
     | n == 1: 1
     | else: fib(n-1) + fib(n-2)

// Ok to add `:` before `|`. This parses the
// same as the prevous example, but this is not the standard
// style (which is to omit unnecessary colons).
define fib:
  lambda (n):
    cond:
     | n == 0: 0
     | n == 1: 1
     | else: fib(n-1) + fib(n-2)

// Adding parentheses is ok, at least with the obvious handling
// of parentheses by the use of sapling notation, but the
// parentheses are apparent in the sampling parse.
(define fib:
  (lambda (n):
    (cond
      | (n == 0): 0
      | (n == 1): 1
      | else: (fib(n-1) + fib(n-2)))))

// For maximal noise, you could add parentheses and trailing colons.
// But we won't.

// START: all of the next `fib` definitions are exactly the same

define fib(n):
  match n
   | 0: 0
   | 1: 1
   | n: fib(n-1) + fib(n-2)

define fib(n):
  match n:
   | 0: 0
   | 1: 1
   | n: fib(n-1) + fib(n-2)

define fib(n):
  match n | 0: 0
          | 1: 1
          | n: fib(n-1) + fib(n-2)

define fib(n):
  match n
   | 0:
       0
   | 1:
       1
   | n:
       fib(n-1) + fib(n-2)

define fib(n):
  match n { | 0 { 0 }
            | 1 { 1 }
            | n { fib(n-1) + fib(n-2) } }

define fib(n):
  match n { | { 0: 0 } | { 1: 1 } | n: fib(n-1) + fib(n-2) }

define fib(n): match n { | { 0: 0 } | { 1: 1 } | n: fib(n-1) + fib(n-2) }

define fib(n) { match n { | { 0: 0 } | { 1: 1 } | n: fib(n-1) + fib(n-2) } }

define fib(n) { match n { | 0 {0} | 1 {1} | n { fib(n-1) + fib(n-2) } } }

define fib(n) { match n { | { 0 {0} } | { 1 {1} } | { n { fib(n-1) + fib(n-2) } } } }

define fib(n) { match n | { 0 {0} } | { 1 {1} } | { n { fib(n-1) + fib(n-2) } } }

// END equivalent `fib` definitions

define make_adder(n):
  lambda (m):
    printf("adding to ~a\n", m)
    m+n

define analyze(n):
  if n == 0
   | printf("zero\n")
   | printf("other\n")
  printf("done\n")

define analyze(n):
  if n == 0
   | printf("zero\n")
     printf("done saying zero\n")
   | printf("other\n")
     printf("done saying other\n")

struct posn(x, y)

struct color_posn(col):
  extends posn
  mutable

struct posn(x mutable,
            y = 7):
  methods equality:
    define equal(a, b):
      is_posn(b) => (a.x == b.x && a.y == b.y)
    define hash(a):
      17
    define secondary_hash(a):
      19

struct posn(x, y):
  property prop_equal_and_hash:
    let (hc = lambda (a: posn, hc):
                 hc(a.x) + hc(a.y),
         eql = lambda (a: posn, b: posn, eql):
                 eql(a.x, b.x) && eql(a.y, b.y)):
      values(eql, hc, hc)

struct posn(x, y):
  property prop_equal_and_hash:
    let (hc = lambda (a: posn, hc):
                hc(a.x) + hc(a.y)):
      (lambda (a: posn, b: posn, eql):
         eql(a.x, b.x) && eql(a.y, b.y),
       hc,
       hc)

// Another possibile approach to syntax for `struct`:
struct posn:
  fields:
    x mutable
    y = 7
  methods equality:
    define equal(a, b):
      is_posn(b) => (a.x == b.x && a.y == b.y)
    define hash(a):
      17
    define secondary_hash(a):
      19
  property prop_quality: "high"

define fourth(n :: Integer):
  define m: n*n
  define v: m*m
  printf("~a^4 = ~a\n", n, v)
  v

define exp(n :: Integer, base :> base = 2.718281828459045):
  if (n == 1)
   | base
   | base * exp(n-1, base :> base)

define positive_p(n): if n > 0 | true | false

define go():
  define helper(n):
    list(n, n)
  define more(m):
    if m == 0 | "done"
              | more(m - 1)
  helper(more(9))

define approx(x):
  match x
   | something(v):
       printf("got it\n")
       v
   | nothing: 0

// With two `:`s on one line, there's no way to
// add to the first `:`
define approx_thunk(x):
  match x
   | something(v): lambda (): v
   | nothing: lambda (): 0

// Enough indentation for `v` means that it continues the
// implicit second `:`, so the `lambda` body has `v`:
define approx_thunk(x):
  match x
   | something(v): lambda ():
                      v
   | nothing: lambda (): 0

define approx_thunk(x):
  match x
   | something(v): lambda
                    | (): v
                    | (n): v+n
   | nothing: lambda
               | (): 0
               | (n): n

define curried:
  lambda (x):
    lambda (y):
      lambda (z):
        list(x, y, z)

define curried: lambda (x):
                  lambda (y):
                    lambda (z):
                      list(x, y, z)

define dictionary: dict:
                      foo: 17
                      bar: string
                      baz: true

define colors:
  list(
    red,
    green,
    blue,
    orange,
  )

define f(x_something,
         y_something_else,
         z_also_long_name):
  5

define sum(l):
  let loop(l = l):
    if is_null(l)
     | 0
     | first(l) + loop(rest(l))

define show_all(l):
  for (x = in_list(l)):
    print(x)
    newline()

define show_zip(l, l2):
  for (x = in_list(l),
       x2 = in_list(l2)):
    print(x)
    print_string(" ")
    print(x2)
    newline()

define show_combos_not_same(l, l2):
  for (x = in_list(l)):
   then (x2 = in_list(l2)):
     when !is_equal(x, x2):
       print(x)
       print_string(" ")
       print(x2)
       newline()

define map(f, l):
  for list (x = in_list(l)):
    f(x)

define partition(l, pred):
  for fold (yes = empty,
            no = empty,
            result (reverse(yes), reverse(no))):
   with (x = in_list(l)):
     if pred(x)
      | (cons(x, yes), no)
      | (yes, cons(x, no))

local:
  with:
    define x: 1
    define y: 2
  in:
   x+y
